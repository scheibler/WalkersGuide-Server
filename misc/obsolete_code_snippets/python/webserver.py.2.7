### old webserver.py stuff
#
#    @cherrypy.tools.json_in()
#    def follow_this_way(self):
#        # set gzip header
#        cherrypy.response.headers['Content-Type'] = 'application/gzip'
#        # create the return tuple
#        return_tuple = {}
#        return_tuple['route'] = []
#        return_tuple['warning'] = ""
#        return_tuple['error'] = ""
#        translator = Translator(Config().get_param("default_language"))
#
#        # parse json encoded input
#        input = helper.convert_dict_values_to_utf8( cherrypy.request.json )
#
#        # options
#        if input.has_key("options") == False:
#            return_tuple['error'] = translator.translate("message", "no_route_options")
#            return helper.zip_data(return_tuple)
#        elif type(input['options']) != type({}):
#            return_tuple['error'] = translator.translate("message", "no_route_options")
#            return helper.zip_data(return_tuple)
#        options = input['options']
#        # user language
#        language = ""
#        if options.has_key("language") == True:
#            language = options['language']
#        # if the user sends a language, which is not german, take the default language setting
#        if language != "de":
#            language = Config().get_param("default_language")
#        # initialize the translator object with the user's choosen language
#        translator = Translator(language)
#
#        # start point
#        if input.has_key("start_point") == False:
#            return_tuple['error'] = translator.translate("message", "no_start_point")
#            return helper.zip_data(return_tuple)
#        start_point = input['start_point']
#        if start_point.has_key("name") == False:
#            return_tuple['error'] = translator.translate("message", "start_point_no_name")
#            return helper.zip_data(return_tuple)
#        elif start_point.has_key("lat") == False:
#            return_tuple['error'] = translator.translate("message", "start_point_no_latitude")
#            return helper.zip_data(return_tuple)
#        elif start_point.has_key("lon") == False:
#            return_tuple['error'] = translator.translate("message", "start_point_no_longitude")
#            return helper.zip_data(return_tuple)
#        elif start_point.has_key("type") == False:
#            return_tuple['error'] = translator.translate("message", "start_point_no_type")
#            return helper.zip_data(return_tuple)
#
#        # further options
#        if options.has_key("way_id") == False:
#            return_tuple['error'] = translator.translate("message", "no_way_id")
#            return helper.zip_data(return_tuple)
#        if options.has_key("bearing") == False:
#            return_tuple['error'] = translator.translate("message", "no_bearing_value")
#            return helper.zip_data(return_tuple)
#        add_all_intersections = False
#        if options.has_key("add_all_intersections") == True:
#            if options['add_all_intersections'] == "yes":
#                add_all_intersections = True
#        way = DBControl().fetch_data("SELECT nodes from ways where id = %d" % options['way_id'])
#        if way.__len__() == 0:
#            return_tuple['error'] = translator.translate("message", "way_id_invalid")
#            return helper.zip_data(return_tuple)
#
#        # create session id
#        if options.has_key("session_id") == False:
#            return_tuple['error'] = translator.translate("message", "no_session_id_option")
#            return helper.zip_data(return_tuple)
#        session_id = options['session_id']
#        # try to cancel prior request
#        if Config().clean_old_session(session_id) == False:
#            return_tuple['error'] = translator.translate("message", "old_request_still_running")
#            return helper.zip_data(return_tuple)
#        if Config().number_of_session_ids() == Config().get_param("thread_pool") - 1:
#            return_tuple['error'] = translator.translate("message", "server_busy")
#            return helper.zip_data(return_tuple)
#        Config().add_session_id(session_id)
#
#        # get a route
#        route_logger = RouteLogger("routes", "%s---way_id.%s" % (start_point['name'], options['way_id']))
#        rfc = RouteFootwayCreator(session_id, route_logger, translator, 1.0,
#                ["big_streets", "small_streets", "paved_ways", "unpaved_ways", "unclassified_ways", "steps"], [])
#        try:
#            route = rfc.follow_this_way(start_point,
#                    options['way_id'], options['bearing'], add_all_intersections)
#        except RouteFootwayCreator.FootwayRouteCreationError as e:
#            route_logger.append_to_log("\n----- result -----\ncanceled")
#            Config().confirm_removement_of_session_id(session_id)
#            return_tuple['route'] = []
#            return_tuple['error'] = "%s" % e
#            return helper.zip_data(return_tuple)
#        # return calculated route
#        return_tuple['route'] = route
#        return_tuple['description'] = rfc.get_route_description( return_tuple['route'] )
#        route_logger.append_to_log("\n----- result -----\n")
#        route_logger.append_to_log( json.dumps( return_tuple['route'], indent=4, encoding="utf-8") + "\n----- end of route -----\n")
#        # convert return_tuple to json and zip it, before returning
#        Config().confirm_removement_of_session_id(session_id)
#        return helper.zip_data(return_tuple)
#    follow_this_way.exposed = True
#
#    @cherrypy.tools.json_in()
#    def get_transport_routes(self):
#        # set gzip header
#        cherrypy.response.headers['Content-Type'] = 'application/gzip'
#        # create the return tuple
#        return_tuple = {}
#        return_tuple['transport_routes'] = {}
#        return_tuple['warning'] = ""
#        return_tuple['error'] = ""
#        translator = Translator(Config().get_param("default_language"))
#
#        # parse json encoded input
#        input = helper.convert_dict_values_to_utf8( cherrypy.request.json )
#
#        # options object
#        if input.has_key("options") == False:
#            return_tuple['error'] = translator.translate("message", "no_route_options")
#            return helper.zip_data(return_tuple)
#        elif type(input['options']) != type({}):
#            return_tuple['error'] = translator.translate("message", "no_route_options")
#            return helper.zip_data(return_tuple)
#        options = input['options']
#
#        # user language
#        language = ""
#        if options.has_key("language") == True:
#            language = options['language']
#        # if the user sends a language, which is not german, take the default language setting
#        if language != "de":
#            language = Config().get_param("default_language")
#        # initialize the translator object with the user's choosen language
#        translator = Translator(language)
#
#        # source route
#        if input.has_key("source_route") == False:
#            return_tuple['error'] = translator.translate("message", "no_source_route")
#            return helper.zip_data(return_tuple)
#        elif type(input['source_route']) != type([]):
#            return_tuple['error'] = translator.translate("message", "no_source_route")
#            return helper.zip_data(return_tuple)
#        elif input['source_route'].__len__() < 3:
#            return_tuple['error'] = translator.translate("message", "source_route_incomplete")
#            return helper.zip_data(return_tuple)
#        source_route = input['source_route']
#
#        # check if route is valid
#        index = 0
#        number_of_transport_parts = 0
#        for part in source_route:
#            if part['type'] in ["point", "intersection", "poi", "station"]:
#                index += 1
#            elif part['type'] in ["footway", "transport"]:
#                index -= 1
#                if part['sub_type'] == "transport_place_holder":
#                    number_of_transport_parts += 1
#            else:
#                index = -1
#                break
#        if index != 1:
#            return_tuple['error'] = translator.translate("message", "source_route_incomplete")
#            return helper.zip_data(return_tuple)
#        if number_of_transport_parts == 0:
#            return_tuple['error'] = translator.translate("message", "source_route_no_transport_parts")
#            return helper.zip_data(return_tuple)
#        if number_of_transport_parts > 1:
#            return_tuple['error'] = translator.translate("message", "source_route_multiple_transport_parts")
#            return helper.zip_data(return_tuple)
#
#        # further options
#        if options.has_key("number_of_possible_routes") == False:
#            options['number_of_possible_routes'] = 3
#
#        # create session id
#        if options.has_key("session_id") == False:
#            return_tuple['error'] = translator.translate("message", "no_session_id_option")
#            return helper.zip_data(return_tuple)
#        session_id = options['session_id']
#        # try to cancel prior request
#        if Config().clean_old_session(session_id) == False:
#            return_tuple['error'] = translator.translate("message", "old_request_still_running")
#            return helper.zip_data(return_tuple)
#        if Config().number_of_session_ids() == Config().get_param("thread_pool") - 1:
#            return_tuple['error'] = translator.translate("message", "server_busy")
#            return helper.zip_data(return_tuple)
#        Config().add_session_id(session_id)
#
#        # create route logger object
#        route_logger = RouteLogger("routes", "public_transport---%s---%s" % (source_route[0]['name'], source_route[-1]['name']))
#
#        # parse route parts
#        rtc = RouteTransportCreator(session_id, route_logger, translator)
#        for i in range(1, source_route.__len__(), 2):
#            if source_route[i]['type'] == "footway" and source_route[i]['sub_type'] == "transport_place_holder":
#                result = rtc.find_best_transport_routes(source_route[i-1], source_route[i+1],
#                        options['number_of_possible_routes'])
#                return_tuple['transport_routes'] = result.routes
#                pre_source_route = source_route[0:i-1]
#                post_source_route = source_route[i+2:source_route.__len__()]
#                break
#        if return_tuple['transport_routes'] == None:
#            Config().confirm_removement_of_session_id(session_id)
#            route_logger.append_to_log("\n----- result -----\ncanceled")
#            return_tuple['transport_routes'] = []
#            return_tuple['error'] = translator.translate("message", "process_canceled")
#            return helper.zip_data(return_tuple)
#
#        for key in return_tuple['transport_routes'].keys():
#            serializable_list = []
#            for route in return_tuple['transport_routes'][key]:
#                route.route = pre_source_route + route.route + post_source_route
#                serializable_list.append(route.__dict__)
#            return_tuple['transport_routes'][key] = serializable_list
#        f = open("/tmp/tr_routes.json", "w")
#        f.write(json.dumps(return_tuple['transport_routes'], indent=4, encoding="utf-8"))
#        f.close()
#
#        # convert return_tuple to json and zip it, before returning
#        Config().confirm_removement_of_session_id(session_id)
#        return helper.zip_data(return_tuple)
#    get_transport_routes.exposed = True
